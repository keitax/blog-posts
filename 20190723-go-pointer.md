---
labels: [Go, Go入門]
---

# Goのポインタはいつ使うべきで、いつ使うべきでないのか

JavaやPHPを中心に使っている人が、Goを学び始めるときに、つまずきがちな機能としてポインタがあると思います。
既存のGoのコードを読むと、ポインタを使っている箇所や使っていない箇所があり、どのような規則で使い分けているのか分かりづらいといったことがあるのではないでしょうか。
本記事では、Goのポインタの使い分けの法則について説明します。

## 簡単な判別方法 - データ型で判別

厳密にいつポインタを使うべきなのかはケースバイケースで、ポインタを利用する目的によって異なります。
しかし多くの場合に当てはまる簡単な判別方法があります。

それは、「データ型」で判別する方法です。以下のように対象のデータ型によってポインタを用いるか用いないか判断します。

データ型 | ポインタを使うか
--- |  ---
int, float | no
string | no
array | yes
slice | no
map | no
struct | yes
interface | no

つまり、arrayとstructのみポインタを用い、それ以外のデータ型には用いません。
このルールで使用していれば、感覚値ですが8割方問題ないです。

具体的には以下のような感じです。

```Go
type Foo struct {
	X int
	Y int
}

n := 0          // int型: ポインタ非利用
str := "foobar" // string型: ポインタ非利用
foo := &Foo{}   // *Foo型: ポインタ利用
```

## Goでのメモリモデル

上記の判別法でなぜ良いのかは、Goのメモリモデルついて理解すると分かりやすいです。

### 変数代入の仕組み

まず、Goでの代入は値渡しです。つまり代入では右辺の値が、左辺にコピーされます。例えば10という値が右辺にあれば
同じく10という値として左辺にコピーされます。

```
x := 10 // xに10がコピー
y = x   // yに10がコピー
```

### 各データ型のメモリ構造

右辺値が左辺にコピーといいますが、ここで問題になるのが、右辺値の実態です。
"abc"を何らかの変数に代入するとき、"abc" の文字列すべてがコピーされるのでしょうか、
それともJavaなどの言語のように、"abc" を指し示す別のデータがコピーされるのでしょうか。

ここがデータ型によって異なる部分で、ポインタを使うのか使わないかの分岐点になります。

値の実態はデータ型毎に以下のようになります。

データ型 | 実態 | バイト長
--- |  --- | ---
int, float, etc... | 数値データ | int32→4, float64→8, etc...
string | 文字列データを指すポインタ | 1
array | 格納している値すべて | 格納しているデータのバイト長*配列長
slice | スライスデータへのポインタ+スライス長+スライスサイズ | 3
map | マップデータを指すポインタ | 1
struct | 格納している各フィールド値 | 各フィールドのバイト長合計
interface | 実態値へのポインタ+実態値の型データへのポインタ | 2

### arrayとstructでポインタを使う第一の理由

以上の表を見ると、なぜarrayとstructのみポインタを用いるべきなのかが分かると思います。この2つのデータ型は格納するデータにもよりますが、バイト長が長く、ポインタを使わなければ代入のコストが大きくなってしまうわけです。
逆にそれら以外のデータ型については、ポインタを使ってもほとんど代入のコスト削減とならず使う意味がありません。

## 例外的ケース

ここまでで、arrayとstructのみはメモリコピーのコスト削減のためにポインタを用いると良いと分かりました。
しかし、ポインタを用いる or 用いないはメモリコピーのコスト以外が理由となることもあります。
そのため、上記のルールには例外があります。代表的なケースを2つ紹介します。

### nilを表現したい

Goでは、intやstring型の変数にはnilを代入できません。このため「データを設定されていないこと」といった状態を表現しにくいです。その場合、ポインタを使うと便利です。

```
var x int
x = nil // NG!

var xp *int
var x int = 100
xp = &x  // 100を代入
xp = nil // OK!
```

### データの中身をコピーしたい

ポインタを使うとデータの中身をコピーすることはできません。そのため、arrayやstructでもポインタをあえて使わないことがあります。

```
type Foo struct {
	X int
}

func bar() {
	f1 := &Foo{X: 100}
	f2 = *f1 // structの中身ごとコピー。f2にf1あえて*演算子でポインタを外して代入
	f2.X = 200 // f1のデータは変更されない
}
```

## まとめ

Goプログラミング入門時にハマりがちな、ポインタの使いどころについて、判別方法を紹介しました。
データ型を見て判別するのが基本的には良く、特にarrayとstructについては代入時のメモリコピー削減のためにポインタを用います。
ただし、ポインタを用いる目的はメモリコピーを避けること以外にもあるため、例外的なケースもあることをご紹介しました。
